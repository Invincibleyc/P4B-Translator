/* Automatically generated by p4c-ebpf from /media/yec/WORK/Programs/P4-verification/P4B-Translator/testdata/p4_16_samples/lpm_ebpf.p4 on Thu Feb 17 22:09:22 2022
 */
#ifndef _P4_GEN_HEADER_
#define _P4_GEN_HEADER_
#include "ebpf_test.h"

#define MAP_PATH "/sys/fs/bpf"
struct Ethernet_h {
    u64 dstAddr; /* EthernetAddress */
    u64 srcAddr; /* EthernetAddress */
    u16 etherType; /* bit<16> */
    u8 ebpf_valid;
};

struct IPv4_h {
    u8 version; /* bit<4> */
    u8 ihl; /* bit<4> */
    u8 diffserv; /* bit<8> */
    u16 totalLen; /* bit<16> */
    u16 identification; /* bit<16> */
    u8 flags; /* bit<3> */
    u16 fragOffset; /* bit<13> */
    u8 ttl; /* bit<8> */
    u8 protocol; /* bit<8> */
    u16 hdrChecksum; /* bit<16> */
    u32 srcAddr; /* IPv4Address */
    u32 dstAddr; /* IPv4Address */
    u8 ebpf_valid;
};

struct Headers_t {
    struct Ethernet_h ethernet; /* Ethernet_h */
    struct IPv4_h ipv4; /* IPv4_h */
};

struct pipe_Check_src_ip_key {
    u32 field0; /* headers.ipv4.srcAddr */
};
enum Check_src_ip_0_actions {
    pipe_Reject,
    _NoAction,
};
struct pipe_Check_src_ip_value {
    enum Check_src_ip_0_actions action;
    union {
        struct {
            u32 add;
        } pipe_Reject;
        struct {
        } _NoAction;
    } u;
};
#if CONTROL_PLANE
static void init_tables() 
{
    u32 ebpf_zero = 0;
    {
        int tableFileDescriptor = BPF_OBJ_GET(MAP_PATH "/pipe_Check_src_ip_defaultAction");
        if (tableFileDescriptor < 0) { fprintf(stderr, "map pipe_Check_src_ip_defaultAction not loaded\n"); exit(1); }
        struct pipe_Check_src_ip_value value = {
            .action = _NoAction,
            .u = {._NoAction = {}},
        };
        int ok = BPF_USER_MAP_UPDATE_ELEM(tableFileDescriptor, &ebpf_zero, &value, BPF_ANY);
        if (ok != 0) { perror("Could not write in pipe_Check_src_ip_defaultAction"); exit(1); }
    }
}
#endif
#endif
