/* Automatically generated by p4c-ebpf from /media/yec/WORK/Programs/P4-verification/P4B-Translator/testdata/p4_16_samples/ebpf_conntrack_extern.p4 on Thu Feb 17 22:09:24 2022
 */
#include "test.h"
#include "ebpf_test.h"

enum ebpf_errorCodes {
    NoError,
    PacketTooShort,
    NoMatch,
    StackOutOfBounds,
    HeaderTooShort,
    ParserTimeout,
    ParserInvalidArgument,
};

#define EBPF_MASK(t, w) ((((t)(1)) << (w)) - (t)1)
#define BYTES(w) ((w) / 8)
#define write_partial(a, s, v) do { u8 mask = EBPF_MASK(u8, s); *((u8*)a) = ((*((u8*)a)) & ~mask) | (((v) >> (8 - (s))) & mask); } while (0)
#define write_byte(base, offset, v) do { *(u8*)((base) + (offset)) = (v); } while (0)

void* memcpy(void* dest, const void* src, size_t num);

REGISTER_START()
REGISTER_END()

SEC("prog")
int ebpf_filter(SK_BUFF *skb){
    struct Headers_t headers = {
        .ethernet = {
            .ebpf_valid = 0
        },
        .ipv4 = {
            .ebpf_valid = 0
        },
        .tcp = {
            .ebpf_valid = 0
        },
    };
    unsigned ebpf_packetOffsetInBits = 0;unsigned ebpf_packetOffsetInBits_save = 0;
    enum ebpf_errorCodes ebpf_errorCode = NoError;
    void* ebpf_packetStart = ((void*)(long)skb->data);
    void* ebpf_packetEnd = ((void*)(long)(skb->data + skb->len));
    u8 pass = 0;
    u32 ebpf_zero = 0;
    unsigned char ebpf_byte;

    goto start;
    start: {
/* extract(headers.ethernet)*/
        if (ebpf_packetEnd < ebpf_packetStart + BYTES(ebpf_packetOffsetInBits + 112)) {
            ebpf_errorCode = PacketTooShort;
            goto reject;
        }
        headers.ethernet.dstAddr = (u64)((load_dword(ebpf_packetStart, BYTES(ebpf_packetOffsetInBits)) >> 16) & EBPF_MASK(u64, 48));
        ebpf_packetOffsetInBits += 48;

        headers.ethernet.srcAddr = (u64)((load_dword(ebpf_packetStart, BYTES(ebpf_packetOffsetInBits)) >> 16) & EBPF_MASK(u64, 48));
        ebpf_packetOffsetInBits += 48;

        headers.ethernet.etherType = (u16)((load_half(ebpf_packetStart, BYTES(ebpf_packetOffsetInBits))));
        ebpf_packetOffsetInBits += 16;

        headers.ethernet.ebpf_valid = 1;
/* extract(headers.ipv4)*/
        if (ebpf_packetEnd < ebpf_packetStart + BYTES(ebpf_packetOffsetInBits + 160)) {
            ebpf_errorCode = PacketTooShort;
            goto reject;
        }
        headers.ipv4.version = (u8)((load_byte(ebpf_packetStart, BYTES(ebpf_packetOffsetInBits)) >> 4) & EBPF_MASK(u8, 4));
        ebpf_packetOffsetInBits += 4;

        headers.ipv4.ihl = (u8)((load_byte(ebpf_packetStart, BYTES(ebpf_packetOffsetInBits))) & EBPF_MASK(u8, 4));
        ebpf_packetOffsetInBits += 4;

        headers.ipv4.diffserv = (u8)((load_byte(ebpf_packetStart, BYTES(ebpf_packetOffsetInBits))));
        ebpf_packetOffsetInBits += 8;

        headers.ipv4.totalLen = (u16)((load_half(ebpf_packetStart, BYTES(ebpf_packetOffsetInBits))));
        ebpf_packetOffsetInBits += 16;

        headers.ipv4.identification = (u16)((load_half(ebpf_packetStart, BYTES(ebpf_packetOffsetInBits))));
        ebpf_packetOffsetInBits += 16;

        headers.ipv4.flags = (u8)((load_byte(ebpf_packetStart, BYTES(ebpf_packetOffsetInBits)) >> 5) & EBPF_MASK(u8, 3));
        ebpf_packetOffsetInBits += 3;

        headers.ipv4.fragOffset = (u16)((load_half(ebpf_packetStart, BYTES(ebpf_packetOffsetInBits))) & EBPF_MASK(u16, 13));
        ebpf_packetOffsetInBits += 13;

        headers.ipv4.ttl = (u8)((load_byte(ebpf_packetStart, BYTES(ebpf_packetOffsetInBits))));
        ebpf_packetOffsetInBits += 8;

        headers.ipv4.protocol = (u8)((load_byte(ebpf_packetStart, BYTES(ebpf_packetOffsetInBits))));
        ebpf_packetOffsetInBits += 8;

        headers.ipv4.hdrChecksum = (u16)((load_half(ebpf_packetStart, BYTES(ebpf_packetOffsetInBits))));
        ebpf_packetOffsetInBits += 16;

        headers.ipv4.srcAddr = (u32)((load_word(ebpf_packetStart, BYTES(ebpf_packetOffsetInBits))));
        ebpf_packetOffsetInBits += 32;

        headers.ipv4.dstAddr = (u32)((load_word(ebpf_packetStart, BYTES(ebpf_packetOffsetInBits))));
        ebpf_packetOffsetInBits += 32;

        headers.ipv4.ebpf_valid = 1;
/* extract(headers.tcp)*/
        if (ebpf_packetEnd < ebpf_packetStart + BYTES(ebpf_packetOffsetInBits + 160)) {
            ebpf_errorCode = PacketTooShort;
            goto reject;
        }
        headers.tcp.srcPort = (u16)((load_half(ebpf_packetStart, BYTES(ebpf_packetOffsetInBits))));
        ebpf_packetOffsetInBits += 16;

        headers.tcp.dstPort = (u16)((load_half(ebpf_packetStart, BYTES(ebpf_packetOffsetInBits))));
        ebpf_packetOffsetInBits += 16;

        headers.tcp.seqNo = (u32)((load_word(ebpf_packetStart, BYTES(ebpf_packetOffsetInBits))));
        ebpf_packetOffsetInBits += 32;

        headers.tcp.ackNo = (u32)((load_word(ebpf_packetStart, BYTES(ebpf_packetOffsetInBits))));
        ebpf_packetOffsetInBits += 32;

        headers.tcp.dataOffset = (u8)((load_byte(ebpf_packetStart, BYTES(ebpf_packetOffsetInBits)) >> 4) & EBPF_MASK(u8, 4));
        ebpf_packetOffsetInBits += 4;

        headers.tcp.res = (u8)((load_byte(ebpf_packetStart, BYTES(ebpf_packetOffsetInBits)) >> 1) & EBPF_MASK(u8, 3));
        ebpf_packetOffsetInBits += 3;

        headers.tcp.ecn = (u8)((load_half(ebpf_packetStart, BYTES(ebpf_packetOffsetInBits)) >> 6) & EBPF_MASK(u8, 3));
        ebpf_packetOffsetInBits += 3;

        headers.tcp.urgent = (u8)((load_byte(ebpf_packetStart, BYTES(ebpf_packetOffsetInBits)) >> 5) & EBPF_MASK(u8, 1));
        ebpf_packetOffsetInBits += 1;

        headers.tcp.ack = (u8)((load_byte(ebpf_packetStart, BYTES(ebpf_packetOffsetInBits)) >> 4) & EBPF_MASK(u8, 1));
        ebpf_packetOffsetInBits += 1;

        headers.tcp.psh = (u8)((load_byte(ebpf_packetStart, BYTES(ebpf_packetOffsetInBits)) >> 3) & EBPF_MASK(u8, 1));
        ebpf_packetOffsetInBits += 1;

        headers.tcp.rst = (u8)((load_byte(ebpf_packetStart, BYTES(ebpf_packetOffsetInBits)) >> 2) & EBPF_MASK(u8, 1));
        ebpf_packetOffsetInBits += 1;

        headers.tcp.syn = (u8)((load_byte(ebpf_packetStart, BYTES(ebpf_packetOffsetInBits)) >> 1) & EBPF_MASK(u8, 1));
        ebpf_packetOffsetInBits += 1;

        headers.tcp.fin = (u8)((load_byte(ebpf_packetStart, BYTES(ebpf_packetOffsetInBits))) & EBPF_MASK(u8, 1));
        ebpf_packetOffsetInBits += 1;

        headers.tcp.window = (u16)((load_half(ebpf_packetStart, BYTES(ebpf_packetOffsetInBits))));
        ebpf_packetOffsetInBits += 16;

        headers.tcp.checksum = (u16)((load_half(ebpf_packetStart, BYTES(ebpf_packetOffsetInBits))));
        ebpf_packetOffsetInBits += 16;

        headers.tcp.urgentPtr = (u16)((load_half(ebpf_packetStart, BYTES(ebpf_packetOffsetInBits))));
        ebpf_packetOffsetInBits += 16;

        headers.tcp.ebpf_valid = 1;
        goto accept;
    }

    reject: { return false; }

    accept:
    {
        u8 hit;
        u8 allow_0;
        {
pass = false;
            if (/* headers.tcp.isValid()*/
            headers.tcp.ebpf_valid) {
allow_0 = /* tcp_conntrack(headers)*/
tcp_conntrack((const struct Headers_t ) headers);
;
                if (allow_0) {
pass = true;                }

            }
        }
    }
    ebpf_end:
    if (pass)
        return true;
    else
        return false;
}
char _license[] SEC("license") = "GPL";
